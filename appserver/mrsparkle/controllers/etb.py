from __future__ import absolute_import
from __future__ import print_function
from builtins import object
from splunk.util import cmp
from functools import cmp_to_key

import datetime
import logging
import re
import sys

import cherrypy
from splunk.appserver.mrsparkle.controllers import BaseController
from splunk.appserver.mrsparkle.lib.decorators import expose_page
from splunk.appserver.mrsparkle.lib.routes import route
from splunk.appserver.mrsparkle import MIME_HTML



from splunk.appserver.mrsparkle.lib import util
import splunk.searchhelp.utils as shu
import splunk.search as se

import xml.sax.saxutils as su
import splunk.bundle as bundle

import splunk.util

logger = logging.getLogger('splunk.appserver.controllers.etb')

_STRING_DELIMITER = "\n"
MAX_SAMPLES = 100
MIN_SAMPLES = 20
MAX_LINES = 15

requiredFields = ["sid", "offset"]

CERROR = "error"
CWARN  = "warn"
CMSG   = "info"
CSUCCESS = "success"

CVALIDLIST = [CERROR, CSUCCESS, CWARN, CMSG]

def errorCMP(x,y):
    x = re.search('class="(.*?)"', x).group(1)
    y = re.search('class="(.*?)"', y).group(1)
    return cmp(CVALIDLIST.index(y),CVALIDLIST.index(x))

def addMessage(parent, msg, msgtype):
    if msgtype not in CVALIDLIST:
        raise Exception("Invalid message type '%s' for '%s'" % (msgtype, msg))
    if isinstance(parent, dict):
        parent = parent['messages']
    if (su.escape(msgtype) == CERROR):
        error_badge = '<svg style="fill:#dc4e41;padding-right:16px;padding-left:16px" focusable="false" height="24px" width="24px" viewBox="0 0 1375 1500" aria-hidden="false" preserveAspectRatio="xMidYMid" xmlns="http://www.w3.org/2000/svg" class="inline_SVG_d13579264976c537_847fc6 main_SVG_d13579264976c537_847fc6"><title>Error</title><path d="M187.5 61.5h1000c103.553 0 187.5 83.947 187.5 187.5v1000c0 103.553-83.947 187.5-187.5 187.5h-1000C83.947 1436.5 0 1352.553 0 1249V249C0 145.447 83.947 61.5 187.5 61.5zm400.79 413.083l32.145 257.167c4.908 39.264 34.086 74.685 69.815 91.187 36.612-16.018 64.87-50.826 69.914-91.187l32.146-257.167C799.18 419.623 759.582 374 703.7 374h-26.8c-55.908 0-95.555 45.033-88.61 100.583zm101.293 644.209c63.283 0 114.584-51.301 114.584-114.584 0-63.282-51.301-114.583-114.584-114.583-63.282 0-114.583 51.3-114.583 114.583s51.3 114.584 114.583 114.584z"></path></svg>'
        parent.append('<p style="display:inline-flex">%s<span style="padding-top: 6px">%s</span></p>' % (error_badge, su.escape(msg)))
    else:
        parent.append('<p class="%s">%s</p>' % (su.escape(msgtype), su.escape(msg)))


"""
1. given an event, we generate a series of checkboxes for attribute=values and _raw phrases.
2. given series of checkboxes or customizes eventtypestring, we search and get example results
3. allow saving and testing
"""


class ETBController(BaseController):
    """/etb"""

    @route('/')
    @expose_page(must_login=True, methods=['GET', 'POST'])
    def index(self, **kwargs):

        cherrypy.response.headers['content-type'] = MIME_HTML
        args = getArgs(kwargs)
        args['testingurl'] = None
        args['etstyles'] = []

        try:
            # IF WE HAVE AN EVENTTYPE AND THE USER IS SAVING IT, RETURN SUCCESS
            if len(args['eventtype'])>0 and save(args):
                args['events'] = []
                args['checkedValues'] = {}
                return self.render_template('etb/index.html', args)
        except Exception as e:
            addMessage(args, "Unable to save eventtype: %s" % e, CERROR)
            #import traceback #addMessage(args, "<pre>Stacktrace: %s</pre>" % traceback.format_exc(), CWARN)

        try:
            getFieldInfo(args)
        except Exception as e:
            # better error generated by getevent
            pass

        # if user modified eventtype and didn't hit preview button, use his; otherwise generate it
        if args['edited']:
            eventtype = args['eventtype']
        else:
            eventtype = args['generatedSearch']

        args['eventtype'] = eventtype
        args['events'] = []
        try:
            args['events'] = getSampleEvents(eventtype, args)
            if not eventTypeExists(args) and len(eventtype)>0:
                args['testingurl'] = self.make_url(['app', args.get('namespace'), 'flashtimeline'],  _qs=[('q', 'search ' + eventtype)])
            args['etstyles'] = getStyles(args)

        except Exception as e:
            addMessage(args, "Unable to get sample events: %s" % e, CERROR)



        # sort warnings before messages. weak.
        args['messages'].sort(key=cmp_to_key(errorCMP))
        args['messages'].reverse()

        return self.render_template('etb/index.html', args)

def getStyles(args):
    names = []
    f = None
    try:
        ns = args['namespace']
        f = open(util.make_splunkhome_path(['etc', 'apps', ns, 'appserver', 'static', 'application.css']))
        lines = f.readlines()
        for line in lines:
            thesenames = re.findall(".splEvent-([^ {]*)", line)
            names.extend(thesenames)
        names.sort()
    except Exception as e:
        pass
    finally:
        if f:
            f.close()
    return names


MAX_JOB_WAIT = 10 # 10seconds

def getSampleEvents(eventtype, args, fast=True):
    results = []

    if eventtype != '':

        if eventtype.strip().startswith("|") or len(shu.getJustCommands(eventtype, None)) > 1:
            raise Exception("Eventtypes cannot contain search commands")

        eventtype = eventtype.replace('\\', '\\\\')
        sid = args['sid']
        if fast:
            # try to finalize jobs so that search job can be used with loadjob
            try:
                job = se.getJob(sid)
                job.finalize()
                se.waitForJob(job, MAX_JOB_WAIT) # job isn't ready immediately after finalize is called.
            except Exception as ee:
                pass
            query = "| loadjob %s | search %s | head %s | fields | abstract maxlines=%s " % (sid, eventtype, MAX_SAMPLES, MAX_LINES)
        else:
            query = "search %s | head %s | fields | abstract maxlines=%s " % (eventtype, MAX_SAMPLES, MAX_LINES)

        maxtime = args.get('maxtime', None)
        if maxtime != None:
            # try to use maxtime to get selecteed event at top
            epochmaxtime = splunk.util.dt2epoch(splunk.util.parseISO(maxtime))
            results = se.searchAll(query, latest_time=epochmaxtime, status_buckets=1,
                                   auto_finalize_ec=MAX_SAMPLES,
                                   max_out=MAX_SAMPLES,
                                   max_count=MAX_SAMPLES, max_time=MAX_JOB_WAIT,
                                   enable_lookups=0, auto_cancel=int(1.5*MAX_JOB_WAIT)
                                   )

        # if we got no results, perhaps the job expired.  rerun the search.
        if fast and len(results) == 0:
            return getSampleEvents(eventtype, args, False)

        # if not enough events, research without time constraint
        if len(results) < MIN_SAMPLES:
            results = se.searchAll(query, status_buckets=1,
                                   auto_finalize_ec=MAX_SAMPLES,
                                   max_out=MAX_SAMPLES,
                                   max_count=MAX_SAMPLES, max_time=MAX_JOB_WAIT,
                                   enable_lookups=0, auto_cancel=int(1.5*MAX_JOB_WAIT)
                                   )
        results =  [ r.raw.getRaw() for r in results ]
    return results

def ignoredField(fieldname):
    return fieldname == '' or fieldname == None or fieldname.startswith('_') or fieldname.startswith('date_') or fieldname == 'punct' or fieldname == 'timestartpos' or fieldname == 'timeendpos'

def getFieldInfo(args):
    event = args['event']
    job = se.getJob(args['sid'])
    summary = job.summary
    if event != None:
        eventValues = {}
        fieldValues = {}
        fieldOrder = []
        for attr in event:
            if ignoredField(attr):
                continue
            fieldOrder.append(attr)
            eventValues[attr] = [str(v) for v in event[attr]] # list
            fieldValues[attr] = summary.fields.get(attr,{'distinctCount':0, 'modes':[]})

            #fieldcount = fieldinfo['count']
            #fielddistinctcount = fieldinfo['distinctCount']
            #fieldValues[attr] = fieldinfo['modes']  # (vd['value'],vd['count'])
        args['eventValues'] = eventValues
        args['fieldValues'] = fieldValues

        fieldOrder.sort(key=lambda x: fieldValues[x]['distinctCount'])
        args['fieldOrder'] = fieldOrder

def quoteAsNeeded(val):
    if not val.isalnum():
        val = val.replace('"', '\\"')
        val = '"%s"' % val
    return val

def getCondition(attr, val):
    val = quoteAsNeeded(val)
    if attr.startswith('_raw'):
        return val
    else:
        return '%s=%s' % (attr, val)

def getArgs(requestArgs):

    for field in requiredFields:
        if field not in requestArgs:
            raise AttributeError('Required field "%s" not provided' % field)

    checkedValues = {}
    # make a map of attrs to set of values checked
    for k, v in requestArgs.items():
        if k.startswith("check"):
            k = k[7:] # check+2digits
            if not k in checkedValues:
                checkedValues[k] = set()
            checkedValues[k].add(v)

    # now generate search from checked features
    searchCondition = []
    for attr, vals in checkedValues.items():
        conds = [getCondition(attr, val) for val in vals]
        if len(conds) == 1:
            searchCondition.append(getCondition(attr, list(vals)[0]))
        else:
            searchCondition.append('(%s)' % (' OR '.join(conds)))
    generatedSearch = ' '.join(searchCondition)

    maxtime = None
    messages = []
    eventSearch, event = getJobInfo(requestArgs, messages)
    rootSearch = ''
    if event != None:
        searchArgs = eventSearch.split('|')[0]
        if searchArgs.startswith("search "):
            searchArgs = searchArgs[7:]
        searchArgs = searchArgs.strip()
        rootSearch = searchArgs
        if searchArgs != "*":
            generatedSearch = ("%s %s" % (searchArgs, generatedSearch)).strip()

        eventValues = {}
        for attr in event:
            eventValues[attr] = event[attr][0] # just use first value
        #eventValues['raw'] = event.raw.getRaw()
        if '_time' in event:
            maxtime = splunk.util.getISOTime(event.toDateTime() + datetime.timedelta(seconds=1))


    return {
    'username':cherrypy.session['user']['name'],
    'namespace': requestArgs.get('namespace', 'search'),
    'sid': requestArgs['sid'],
    'offset': requestArgs['offset'],
    'messages' :messages,
    'eventtype': requestArgs.get('eventtype', ''),
    'rootSearch': rootSearch,
    'generatedSearch': generatedSearch,
    'saveresults': 'save' in requestArgs,
    'edited': requestArgs.get('edited', '') == "True" and not 'preview' in requestArgs,
    'maxtime': maxtime,
    'successmessage': '',
    'checkedValues': checkedValues,
    'event': event,
    'eventTypeName': requestArgs.get('eventTypeName', ""),
    'eventTypeStyle': requestArgs.get('eventTypeStyle', ""),
    'eventTypePriority': requestArgs.get('eventTypePriority', "5")

    }

def getJobInfo(requestArgs, messages):
    try:
        sid = requestArgs['sid']
        offset = requestArgs['offset']
        if sid != '' and offset != '':
            job = se.getJob(sid)
            return job.eventSearch, job.events[int(offset)]
    except Exception as e:
        addMessage(messages, 'Unable to get sample event.  The search job has probably expired: "%s"' % e, CERROR)
        return None, None

def eventTypeExists(args, eventTypeName=None):

    if len(args['eventtype']) == 0:
        return True

    eventtype = args['eventtype']
    props = bundle.getConf('eventtypes', None, args['namespace'], args['username'])
    # for each prop stanza
    for stanzaname in props:
        if eventTypeName == stanzaname:
            addMessage(args, "'%s' eventtype already exists." % eventTypeName, CWARN)
            return True
        stanza = props[stanzaname]
        search = stanza.get("search", "")
        if search.strip().lower() == eventtype.strip().lower():

            # just be nice and don't warn the poor guy if he didn't modify the default search
            if args['rootSearch'] == args['generatedSearch']:
                addMessage(args, "Click on event Event Type Feature checkboxes below to make a new unique eventtype.", CMSG)
            else:
                addMessage(args, "The proposed eventtype is already defined as eventtype '%s'." % stanzaname, CWARN)
            return True
    return False

def illegalStanzaCharacters(name):
    illegalChars = "[]\n\r"
    for ch in illegalChars:
        if ch in name:
            return True
    return False

def invalidEventTypeName(args):
    badname = False
    name = args['eventTypeName']
    if name == '' or len(name) > 50 or illegalStanzaCharacters(name):
        addMessage(args, "Illegal eventtype name.", CERROR)
        return True
    if eventTypeExists(args, eventTypeName=name):
        return True
    return False

def save(args):
    shouldSave = args['saveresults'] == True
    if not shouldSave or invalidEventTypeName(args):
        return False

    etname = args['eventTypeName']
    ns = args['namespace']
    user = args['username']
    etconf = bundle.getConf('eventtypes', None, ns, user)
    stanzaname = etname
    etconf.createStanza(stanzaname)
    # write out each regex to props.conf
    etconf[stanzaname]['search'] = args['eventtype'].replace('\n', ' ').replace('\r', '')

    style = args['eventTypeStyle']
    # if the eventtype has a style, save style to eventtype
    etconf[stanzaname]['color'] = style if (style != "") else 'none'
    etconf[stanzaname]['priority'] = args['eventTypePriority']

    # great success!
    successmsg = "'%s' is now saved as an eventtype." % etname
    addMessage(args, successmsg, CSUCCESS)
    args['successmessage'] = successmsg
    return True


 #.ugettext(message)
def unit_test():
    class FakeSession(dict):
        id = 5
    sessionKey = splunk.auth.getSessionKey('admin', 'changeme')
    try:
        cherrypy.session['sessionKey'] = sessionKey
    except AttributeError:
        setattr(cherrypy, 'session', FakeSession())
        cherrypy.session['sessionKey'] = sessionKey
    cherrypy.session['user'] = { 'name': 'admin' }
    cherrypy.session['id'] = 12345
    cherrypy.config['module_dir'] = '/'
    cherrypy.config['build_number'] = '123'
    cherrypy.request.lang = 'en-US'
    # roflcon
    class elvis(object):
        def ugettext(self, msg):
            return msg
    cherrypy.request.t = elvis()
    # END roflcon

    etber = ETBController()

    argc = len(sys.argv)
    if argc == 3:
        search = sys.argv[1]
        example = sys.argv[2]
        print("search: '%s' example: '%s'" % (search, example))
        out = etber.index(search="index=main %s" % search, fieldname='pid', examples=example, save='true', sid=1255116240.31, offset=0)
        #out = etber.index(search="index=main %s" % search, fieldname='pid', examples=example, save='true')
        print(out)
    else:
        print('Usage: %s "restriction" "example"' % sys.argv[0])

if __name__ == '__main__':
    unit_test()
